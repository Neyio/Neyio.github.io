# 规约

## Mysql 规约

> 部分内容本文参考 《阿里巴巴 JAVA 开发手册中的 MSYQL 规约》

### 1.建表规约

1. 【推荐】库名应与服务名称一致。

2. 【强制】表名复数名词。强制使用复数名次有利于同学在编写 ORM 关系时对应相应的方法名，常见的映射关系都以 N 对多对应为主。

3. 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。

?> 说明:`MySQL` 在 `Windows` 下不区分大小写，但在 `Linux` 下默认是区分大小写。因此，数据库 名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。 正例:`sidebar_configs` 反例:`SidebarConfigs`

4. 【推荐】表的命名要具有表现力，可以使用 **业务名称\_表的作用** 的形式。 正例: `sidebar_configs` / `failed_jobs`

5. 【强制】关联表的建立要求采用 `A表_B表` 单词均为单数形式，按字母序排列两个单词先后。正例： `role_user` ，错误示例：`user_role`。

6. 【强制】主键索引名为 `pk_`字段名;唯一索引名为 `uk_`字段名;普通索引名则为 `idx_`字段名。

?> 说明:`pk_` 即 `primary key`; `uk_` 即 `unique key`; `idx_` 即 `index` 的简称。

7. 【强制】外键以表名在单数形式`_id`，若 ORM 需要查找对应模型，使用时强制约束建立单数形式的方法名。

?> 例如 `phone`表中拥有外键 `user_id`，则需要创建 `user()`方法返回该模型

8. 【强制】表达是与否概念的字段，必须使用 `is_xxx` 的方式命名，数据类型是 `unsigned tinyint` ( `1`表示是，`0`表示否)。

?> 说明:任何字段如果为非负数，必须是 `unsigned`。正例:表达逻辑删除的字段名 `is_ad`，`1` 表示删除，`0` 表示未删除。

9. 【强制】禁用保留字，如 `desc`、`range`、`match`、`delayed` 等，请参考 MySQL 官方保留字。

10. 【强制】小数类型为 `decimal`，禁止使用 `float` 和 `double`，小数和值的精度位数根据应用场景而定。

?> 说明:`float` 和 `double` 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 `decimal`的范围，建议将数据拆成整数和小数分开存储。

11. 【强制】如果存储的字符串长度几乎相等，使用 `char` 定长字符串类型。

12. 【强制】`varchar` 是可变长字符串，不预先分配存储空间，长度不要超过 `5000`，如果存储长 度大于此值，定义字段类型为 `text`，独立出来一张表，用主键来对应，避免影响其它字段索引效率。

13. 【强制】每个表结构必须包含以下字段:`id`, `created_at`, `updated_at` ，中间关联表例如用于 映射用户跟角色的`user_role`关联表可以只有`user_id`和`role_id`。

?> 说明:其中`id`必为主键，类型为`unsigned`; `created_at`, `updated_at` 的类型均为 `date_time` 类型，前者现在时表示被创建的事件，`updated_at`表示被更新的时间。

14. 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。

15. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。

!> 冗余字段应遵循: 一不是频繁修改的字段。二不是 `varchar` 超长字段，更不能是 `text` 字段。
正例: 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。

16. 【推荐】单表行数超过`500`万行或者单表容量超过`2GB`，才推荐进行分库分表。 说明:如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。

17. 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。

### 2.索引规约

1. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。

?> 说明:不要以为唯一索引影响了 `insert` 速度，这个速度损耗可以忽略，但提高查找速度是明 显的;另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 膜拜阿里大佬，墨菲定律 😂😂😂

2. 【强制】超过三个表禁止`join`。需要 `join` 的字段，数据类型必须绝对一致;

!> 多表关联查询时,保证被关联的字段需要有索引。即使双表`join`也要注意表索引、SQL 性能。

3. 【强制】在`varchar`字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。

?> 说明:索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为`20`的索引，区分度会高达 90%以上，可以使用`count(distinct left(列名, 索引长度))/count(*)`的区分度来确定。

4. 【推荐】如果有`order by`的场景，请注意利用索引的有序性。`order by`最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现`file_sort`的情况，影响查询性能。 正例:`where a=? and b=? order by c;` 索引:`a_b_c` 反例:索引中有范围查找，那么索引有序性无法利用，如:`WHERE a>10 ORDER BY b;` 索引`a_b`无法排序。

5. 【推荐】利用覆盖索引来进行查询操作，避免回表。
   说明:如果一本书需要知道第`11`章是什么标题，会翻开第`11`章对应的那一页吗?目录浏览一下就好，这个目录就是起到覆盖索引的作用。 正例:能够建立索引的种类:主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种 效果，用`explain`的结果，`extra`列会出现:`using index`。

6. 【推荐】利用延迟关联或者子查询优化超多分页场景。
   说明:`MySQL`并不是跳过`offset`行，而是取`offset+N`行，然后返回放弃前`offset`行，返回`N`行，那当`offset`特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过 特定阈值的页数进行`SQL`改写。

?> 正例:先快速定位需要获取的`id`段，然后再关联:`SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id`

7. 【推荐`SQL`性能优化的目标:至少要达到`range`级别，要求是`ref`级别，如果可以是`consts`最好。

!> 说明: 1) `consts` 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。 2) `ref` 指的是使用普通的索引(`normal index`)。3) `range` 对索引进行范围检索。

8. 【推荐】建组合索引的时候，区分度最高的在最左边。

?> 正例:如果`where a=? and b=?` ，`a` 列的几乎接近于唯一值，那么只需要单建 `idx_a` 索引即 可。 说明:存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如:`where a>? and b=?` 那么即使 `a` 的区分度更高，也必须把 `b` 放在索引的最前列。

9. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。

10. 【参考】创建索引时避免有如下极端误解: 1)宁滥勿缺。认为一个查询就需要建一个索引。 2)宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。 3)抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。

### 3.SQL 语句

1. 【强制】不要使用 `count(列名)`或 `count(常量)`来替代 `count(*)`，`count(*)`是 SQL92 定义的 标准统计行数的语法，跟数据库无关，跟 `NULL` 和非 `NULL` 无关。 说明:`count(*)`会统计值为 `NULL` 的行，而 `count(列名)`不会统计此列为 `NULL` 值的行。

2. 【强制】`count(distinct col)` 计算该列除 `NULL` 之外的不重复行数，注意 `count(distinct col1, col2)` 如果其中一列全为`NULL`，那么即使另一列有不同的值，也返回为 0。

3. 【强制】当某一列的值全是 `NULL` 时，`count(col)`的返回结果为 `0`，但 `sum(col)`的返回结果为 `NULL`，因此使用 `sum()`时需注意 `NPE` 问题。

?> 正例:可以使用如下方式来避免`sum`的`NPE`问题:`SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;`

4. 【强制】使用 `ISNULL()`来判断是否为 `NULL` 值。

?> 说明:`NULL` 与任何值的直接比较都为 `NULL`。`NULL<>NULL`的返回结果是`NULL`，而不是`false`。`NULL=NULL`的返回结果是`NULL`，而不是`true`。 `NULL<>1`的返回结果是`NULL`，而不是`true`。

5. 【强制】 在代码中写分页查询逻辑时，若 `count` 为 `0` 应直接返回，避免执行后面的分页语句。

6. 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 说明:以学生和成绩的关系为例，学生表中的 `student_id` 是主键，那么成绩表中的 `student_id` 则为外键。如果更新学生表中的 `student_id`，同时触发成绩表中的 `student_id` 更新，即为 级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群;级联更新是强阻 塞，存在数据库更新风暴的风险;外键影响数据库的插入速度。

7. 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。

8. 【强制】数据订正时，删除和修改记录时，要先 `select`，避免出现误删除，确认无误才能执 行更新语句。

9. 【推荐】`in` 操作控制在 `1000` 个之内。

10. 【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数 的区别。

?> 说明:
`SELECT LENGTH("轻松工作");` 返回为`12`
`SELECT CHARACTER_LENGTH("轻松工作");` 返回为`4` 如果需要存储表情，那么选择 `utfmb4` 来进行存储，注意它与 `utf-8` 编码的区别。

11. 【参考】`TRUNCATE TABLE 比 DELETE` 速度快，且使用的系统和事务日志资源少，但 `TRUNCATE` 无事务且不触发 `trigger`，有可能造成事故，故不建议在开发代码中使用此语句。 说明:`TRUNCATE TABLE` 在功能上与不带 `WHERE` 子句的 `DELETE` 语句相同。

## 编码规约

### （一）命名风格

1. 【强制】后台代码中的命名均不能以下划线开始，也不能以下划线或美元符号结束。 前端如遇到下划线开头，表示该变量为私有或该方法为私有方法。PHP 变量不允许以美元符号直接接大写的方式定义。

?> 反例:_name / \_\_name / \$Object / name_ / name\$ /

2. 【强制】类名使用 `UpperCamelCase` 风格，必须遵从大驼峰形式，遇到特殊的大写名词除外，单词和单词间必须做区分，否则会导致阅读性差。
   正例:/ MessageException / AskForLeaveRequest
   反例: MSGException / AskforleaveRequest

3. 【强制】方法名、参数名、成员变量、局部变量都统一使用 `lowerCamelCase` 风格，必须遵从驼峰形式。

?> 正例: localValue / getHttpMessage() / inputUserId

4. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。
   ?>正例:MAX_STOCK_COUNT 反例:MAX_COUNT

5. 【强制】PHP 抽象类以`Contract`结尾；PHP 服务使用`Service`结尾；异常类命名使用 `Exception` 结尾;测试类 命名以它要测试的类的名称开始，以 Test 结尾；控制器必须以`Controller`结尾。

6. 【强制】PHP 数组直接使用`变量 = [ … ]` 定义

7. 【强制】Node 文件目录统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。类名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式。

?> 正例: controller.attendance.xxxx

8.  【强制】切勿所有模块都放在同一目录下，增加代码查找的复杂度，不利于后期维护和拓展，如果模块需要升级或拓展的，建议命名文件夹名为`v1\v2\v3`。

9.  【强制】杜绝完全不规范的缩写，避免望文不知义。

?> 反例:AbstractClass“缩写”命名成 AbsClass;condition“缩写”命名为 condi，此类随 意缩写严重降低了代码的可阅读性。

10. 【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词 组合来表达其意。

?> 正例: 从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository。反例: 变量 const a =0;const b = xxx; 的随意命名方式。

11. 【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。 说明:将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。

?>正例:public class OrderFactory;public class LoginProxy; public class ResourceObserver;

12. 【推荐】尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。

13. 【强制】PHP 接口和实现类的命名有两套规则:

    1. 【强制】对于 `Contract` 和 `Repository` 类，所有对外调用的接口，必须是在`Contract`中定义且实现的。
    2. 【推荐】控制器中应避免出现服务代码实现的片段，控制器的方法尽可能只实现路由功能。

14. 【强制】多状态出口的返回方法，必须以数组或枚举的方式定义返回的结果值，并在必要时加以注释中文含义。

```javascript
#例如：
const outPutState = {
   success: 'ok' ,
   failed: 'failure',
   error: 'error'
}
return {
   status: outPutState['success'],
   ...
}
#反例： return { status: 'success' };
```

15. 【强制】服务层命名规范：使用对应方法前缀进行相关操作，后缀可以是 By 某 Key 用以区分同类型操作的不同入参。

```list
     1.  获取单个对象的方法用get做前缀。  例如： getUserById()
     2.  获取多个对象的方法用list做前缀。 例如： listUsers()
     3.  获取统计值的方法用count做前缀。 例如：countClassStudentsByClassId()
     4.  插入的方法用insert做前缀。     例如： insertUser()
     5.  删除的方法用delete做前缀。     例如： deleteUserById()
     6.  修改的方法用update做前缀。     例如:  updateUserById()
```
